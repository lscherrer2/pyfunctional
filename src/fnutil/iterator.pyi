from __future__ import annotations
from typing import Callable, Any, overload
from collections.abc import Iterable
import collections.abc

__all__ = [
    "Iterator",
    "iterate",
]

def iterate[T](iterable: Iterable[T], /) -> Iterator[T]: ...

class Iterator[T]:
    def __init__(self, inner: Iterable[T]): ...
    def __iter__(self) -> collections.abc.Iterator[T]: ...
    def filter(self, fn: Callable[[T], bool]) -> Iterator[T]: ...
    def filterfalse(self, fn: Callable[[T], bool]) -> Iterator[T]: ...
    def map[U](self, fn: Callable[[T], U]) -> Iterator[U]: ...
    def filter_map[U](self, fn: Callable[[T], U | None]) -> Iterator[U]: ...
    def for_each(self, fn: Callable[[T], Any]) -> None: ...
    def try_for_each(self, fn: Callable[[T], Any]) -> None: ...
    def chain(self, *others: Iterable[T]) -> Iterator[T]: ...
    def enumerate(self) -> Iterator[tuple[int, T]]: ...
    def zip[U](self, other: Iterable[U]) -> Iterator[tuple[T, U]]: ...
    def flatten[U](self: Iterator[Iterable[U]]) -> Iterator[U]: ...
    def collect[U](self, cls: type[U]) -> U: ...
    def sum(self) -> T: ...
    def min(self) -> T: ...
    def max(self) -> T: ...
    def fold[U](self, fn: Callable[[U, T], U], initial: U) -> U: ...
    @overload
    def reduce(self, fn: Callable[[T, T], T], initial: None = None) -> T: ...
    @overload
    def reduce[U](self, fn: Callable[[U, T], U], initial: U) -> U: ...
    def __getitem__(self, i: slice) -> Iterator[T]: ...
    @classmethod
    def _wrap(cls, inner: Iterable[T]) -> Iterator[T]: ...
